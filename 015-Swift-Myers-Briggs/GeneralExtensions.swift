//
//  Extensions.swift
//  010-Swift-Material-Design-Color-Kit
//
//  Created by Audrey Li on 3/27/15.
//  Copyright (c) 2015 UIColle. All rights reserved.
//

import Foundation
import UIKit

extension CGRect {
    func insetMaxSquare(rect: CGRect) -> CGRect {
        var width = rect.width < rect.height ? rect.width : rect.height
        return CGRect(x: rect.midX - rect.width / 2, y: rect.midY - rect.width / 2, width: width, height: width)
    }
    
    func insetSquare(rect: CGRect, dx: CGFloat) -> CGRect {
        if rect.width < rect.height {
            var width = rect.width
            return CGRect(x: rect.midX - rect.width / 2 + dx, y: rect.midY - rect.width / 2 + dx, width: width - 2 * dx, height: width - 2 * dx)
        } else {
            return CGRect(x: rect.midX - rect.height / 2 + dx, y: rect.midY - rect.height / 2 + dx, width: height - 2 * dx, height: height - 2 * dx)
        }
        
    }
    
    
}

extension String {
    
    subscript (i: Int) -> Character {
        return self[advance(self.startIndex, i)]
    }
    
    subscript (i: Int) -> String {
        return String(self[i] as Character)
    }
    
    subscript (r: Range<Int>) -> String {
        return substringWithRange(Range(start: advance(startIndex, r.startIndex), end: advance(startIndex, r.endIndex)))
    }
    
    func explode (separator: Character) -> [String] {
        return split(self, { (element: Character) -> Bool in
            return element == separator
        })
    }
    
}

extension Dictionary {
    
    func each (eachFunction each: (Key, Value) -> ()) {
        
        for (key, value) in self {
            each(key, value)
        }
        
    }
    /**
    Checks if a key exists in the dictionary.
    
    :param: key Key to check
    :returns: true if the key exists
    */
    func has (key: Key) -> Bool {
        return indexForKey(key) != nil
    }
    
    /**
    Creates an Array with values generated by running
    each [key: value] of self through the mapFunction.
    :param: mapFunction
    :returns: Mapped array
    */
    func toArray <V> (mapFunction map: (Key, Value) -> V) -> [V] {
        
        var mapped = [V]()
        
        each {
            mapped.append(map($0, $1))
        }
        
        return mapped
        
    }
    
    
    /**
    Constructs a dictionary containing every [key: value] pair from self
    for which testFunction evaluates to true.
    
    :param: testFunction Function called to test each key, value
    :returns: Filtered dictionary
    */
    func filter (testFunction test: (Key, Value) -> Bool) -> Dictionary {
        
        var result = Dictionary()
        
        for (key, value) in self {
            if test(key, value) {
                result[key] = value
            }
        }
        
        return result
        
    }
    
//    func pick (keys: [Key]) -> Dictionary {
//        return filter { (key: Key, _) -> Bool in
//            return keys.contains(key)
//        }
//    }
    
    /**
    Returns a copy of self, filtered to only have values for the whitelisted keys.
    
    :param: keys Whitelisted keys
    :returns: Filtered dictionary
    */
//    func pick (keys: Key...) -> Dictionary {
//        return pick(unsafeBitCast(keys, [Key].self))
//    }
//    
//    /**
//    Returns a copy of self, filtered to only have values for the whitelisted keys.
//    
//    :param: keys Keys to get
//    :returns: Dictionary with the given keys
//    */
//    func at (keys: Key...) -> Dictionary {
//        return pick(keys)
//    }
    
    /**
    Removes a (key, value) pair from self and returns it as tuple.
    If the dictionary is empty returns nil.
    
    :returns: (key, value) tuple
    */
    mutating func shift () -> (Key, Value)? {
        if let key = keys.first {
            return (key, removeValueForKey(key)!)
        }
        
        return nil
    }
}

extension Array {
    func containsElement<T : Equatable>(obj: T) -> Bool {
        let filtered = self.filter {$0 as? T == obj}
        return filtered.count > 0
    }
    
    // re-arrange index from 123456 to 142356  or 123456789 to 147258369
    func shiftOrder(columns: Int) -> Array {
        
        if self.count % columns == 0 {
            var rows = self.count / columns
            var arr = Array()
     
            for var c = 0 ; c < columns ; c++ {
                for var r = 0; r < rows ; r++ {
                    arr.append(self[c + r * columns])
                }
            }
            return arr
            
        }else {
            return self
        }
        
    }
    
    // delete all the items in self that are equal to element
    mutating func remove <U: Equatable> (element: U) {
        let anotherSelf = self
        
        removeAll(keepCapacity: true)
        
        anotherSelf.each {
            (index: Int, current: Element) in
            if current as U != element {
                self.append(current)
            }
        }
    }
    
    //  Iterates on each element of the array with its index.
    func each (call: (Int, Element) -> ()) {
        
        for (index, item) in enumerate(self) {
            call(index, item)
        }
        
    }
    // Randomly rearranges the elements of self using the Fisher-Yates shuffle
    mutating func shuffle () {
        
        for var i = self.count - 1; i >= 1; i-- {
            let j = Int.random(i)
            swap(&self[i], &self[j])
        }
        
    }
    func shuffled () -> Array {
        var shuffled = self
        
        shuffled.shuffle()
        
        return shuffled
    }
}

class Array2D {
    var cols:Int, rows:Int
    var matrix:[Int]
    
    
    init(cols:Int, rows:Int) {
        self.cols = cols
        self.rows = rows
        matrix = Array(count:cols*rows, repeatedValue:0)
    }
    
    subscript(col:Int, row:Int) -> Int {
        get {
            return matrix[cols * row + col]
        }
        set {
            matrix[cols*row+col] = newValue
        }
    }
    
    func colCount() -> Int {
        return self.cols
    }
    
    func rowCount() -> Int {
        return self.rows
    }
}

//let str1 = "abc"  let str2 = "\u{20DD}def" at(str1+str2, 3)   // d   take(str1+str2, 2) // ab



